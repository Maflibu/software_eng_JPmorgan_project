# -*- coding: utf-8 -*-
"""stock_price_processor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UKDd38pWP6-eARHWfGQLUsCo8F1zOj6P
"""

def getDataPoint(data):
  """
  This function retrieves a data point from the feed and calculates the average price.

  Args:
      data: A dictionary containing stock data (stock name, bid price, ask price).

  Returns:
      A tuple containing stock name, bid price, ask price, and average price.
  """
  stock_name = data["stock"]
  bid_price = data["bid"]
  ask_price = data["ask"]
  price = (bid_price + ask_price) / 2  # Calculate average price
  return stock_name, bid_price, ask_price, price

def getRatio(price_a, price_b):
  """
  This function calculates the ratio of two stock prices, handling division by zero.

  Args:
      price_a: The price of stock A.
      price_b: The price of stock B.

  Returns:
      The ratio of price_a to price_b, or None if price_b is zero.
  """
  if price_b == 0:
    return None  # Handle division by zero
  return price_a / price_b

def main():
  """
  This function continuously retrieves data points, calculates prices and ratios, and prints the results.
  """
  prices = {}  # Dictionary to store stock prices (key: name, value: price)

  # Simulate receiving data points (replace with actual data feed interaction)
  while True:
    data = {"stock": "A", "bid": 10, "ask": 12}  # Example data point
    stock_name, bid_price, ask_price, price = getDataPoint(data)
    prices[stock_name] = price

    data = {"stock": "B", "bid": 8, "ask": 11}  # Example data point
    stock_name, bid_price, ask_price, price = getDataPoint(data)
    prices[stock_name] = price

    # Calculate and print the ratio
    ratio = getRatio(prices["A"], prices["B"])
    if ratio is not None:
      print(f"Ratio of Stock A to Stock B: {ratio}")
    else:
      print("Error: Division by zero occurred. Skipping ratio calculation.")

    # Simulate a delay (replace with actual data feed handling)
    # ...

if __name__ == "__main__":
  main()

import React, { useState, useEffect } from 'react';
import { setInterval, clearInterval } from 'timers'; // For managing data fetching interval

interface StockData {
  stock: string;
  timestamp: number;
  top_ask_price: number;
  // ... other data points if needed
}

const App: React.FC = () => {
  const [data, setData] = useState<StockData[]>([]);
  const [showGraph, setShowGraph] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    // Function to fetch data from server
    const fetchData = async () => {
      setIsLoading(true); // Show loading indicator
      try {
        const response = await fetch('/api/stock-data'); // Replace with actual API endpoint
        const newData = await response.json() as StockData[];
        setData((prevData) => [...prevData, ...newData]); // Efficiently merge new data
      } catch (error) {
        console.error('Error fetching data:', error);
      } finally {
        setIsLoading(false); // Hide loading indicator
      }
    };

    // Initial fetch and interval for continuous updates
    fetchData();
    const intervalId = setInterval(fetchData, 5000); // Update every 5 seconds

    // Cleanup function to stop interval on unmount
    return () => clearInterval(intervalId);
  }, []); // Empty dependency array ensures useEffect runs only once

  const handleStartStreaming = () => {
    setShowGraph(true); // Show graph on button click
  };

  // Conditional rendering of graph with loading indicator
  const renderGraph = () => {
    if (!showGraph) return null;

    return (
      <>
        {isLoading && <p>Loading data...</p>}
        {!isLoading && data.length > 0 && (
          <Graph data={data} /> // Render graph only if data is loaded and not empty
        )}
        {!isLoading && data.length === 0 && <p>No data available yet.</p>}
      </>
    );
  };

  return (
    <div>
      <button onClick={handleStartStreaming}>Start Streaming Data</button>
      {renderGraph()}
    </div>
  );
};

export default App;

import React, { useRef } from 'react';

interface GraphProps {
  data: StockData[];
}

const Graph: React.FC<GraphProps> = ({ data }) => {
  const elemRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!elemRef.current) return;

    const viewer = new PerspectiveViewerElement(elemRef.current); // Assuming Perspective setup
    viewer.setData({
      rows: data.map((d) => ({ stock: d.stock, timestamp: d.timestamp })),
      columns: ['top_ask_price'],
      aggregates: [
        { stock: 'distinct', top_ask_price: 'avg', timestamp: 'distinct' },
      ],
      view: 'y_line',
      'column-pivots': ['stock'],
      'row-pivots': ['timestamp'],
    });
  }, [data]); // Re-render graph on data updates

  return <div ref={elemRef} />;
};

export default Graph;

import React, { useState, useEffect } from 'react';
import { setInterval, clearInterval } from 'timers';

interface StockData {
  stock: string;
  timestamp: number;
  price: number;
}

const App: React.FC = () => {
  const [dataA, setDataA] = useState<StockData[]>([]);
  const [dataB, setDataB] = useState<StockData[]>([]);
  const [ratio, setRatio] = useState(null); // Ratio between stock prices
  const [historicalAverageRatio, setHistoricalAverageRatio] = useState(null); // 12-month historical average
  const [isAlertVisible, setIsAlertVisible] = useState(false); // Alert flag

  useEffect(() => {
    // Function to fetch data from server
    const fetchData = async () => {
      try {
        const responseA = await fetch('/api/stock-data/stockA'); // Replace with actual API endpoints
        const newDataA = await responseA.json() as StockData[];
        setDataA((prevData) => [...prevData, newDataA]);

        const responseB = await fetch('/api/stock-data/stockB');
        const newDataB = await responseB.json() as StockData[];
        setDataB((prevData) => [...prevData, newDataA]);

        // Calculate ratio and update state
        if (newDataA.length > 0 && newDataB.length > 0) {
          const latestPriceA = newDataA[newDataA.length - 1].price;
          const latestPriceB = newDataB[newDataB.length - 1].price;
          setRatio(latestPriceA / latestPriceB);
        }
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };

    // Initial fetch and interval for continuous updates
    fetchData();
    const intervalId = setInterval(fetchData, 5000); // Update every 5 seconds

    // Cleanup function to stop interval on unmount
    return () => clearInterval(intervalId);
  }, []); // Empty dependency array ensures useEffect runs only once

  useEffect(() => {
    // Calculate historical average ratio (logic placeholder)
    // Replace this with actual logic to calculate 12-month average ratio based on data
    setHistoricalAverageRatio(0.8); // Placeholder value for demonstration
  }, [dataA, dataB]); // Recalculate average when data changes

  useEffect(() => {
    // Check for threshold breach and trigger alert
    if (ratio !== null && historicalAverageRatio !== null) {
      const threshold = historicalAverageRatio * 0.1; // +/- 10% threshold
      const lowerBound = historicalAverageRatio - threshold;
      const upperBound = historicalAverageRatio + threshold;

      if (ratio < lowerBound || ratio > upperBound) {
        setIsAlertVisible(true);
      } else {
        setIsAlertVisible(false);
      }
    }
  },